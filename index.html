<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Puzzle Surprise</title>

<style>
body {
    font-family: Arial, sans-serif;
    background: #ffe6ec;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* White box around the puzzle */
#puzzle-box {
    width: 340px;
    padding: 20px;
    background: white;
    border-radius: 16px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    margin-top: 20px;
    display: none;
    text-align: center;
}

#puzzle-container {
    position: relative;
    width: 300px;
    height: 300px;
    margin: auto;
}

.tile {
    position: absolute;
    box-sizing: border-box;
    border: 1px solid white;
    cursor: pointer;
    transition: top 0.25s, left 0.25s;
}

#controls { margin-top: 20px; }

button {
    padding: 10px 20px;
    margin: 5px;
    background: #ff4d6d;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
}

#puzzle-message {
    margin-top: 20px;
    display: none;
    background: #fff0f5;
    padding: 15px;
    border-radius: 12px;
    font-weight: bold;
}

#puzzle-back {
    margin-top: 20px;
}
</style>
</head>

<body>

<h2>Puzzle Surprise</h2>

<!-- Size Buttons -->
<div id="controls">
    <button onclick="startPuzzle(2)">2×2</button>
    <button onclick="startPuzzle(3)">3×3</button>
    <button onclick="startPuzzle(4)">4×4</button>
</div>

<!-- Wrapped Puzzle Box -->
<div id="puzzle-box">
    <div id="puzzle-container"></div>
    <div id="puzzle-message"></div>
    <button id="puzzle-back" onclick="closePuzzle()">Back</button>
</div>

<script>
/* Messages for each puzzle */
const messages = [
    "You are the best girlfriend!",
    "You make me so happy and I love you so much!",
    "I am sorry"
];

/* Images for 2×2, 3×3, 4×4 */
const puzzleImages = [
    "Puzzel1.JPG",
    "Puzzel2.JPG",
    "Puzzel3.jpeg"
];

let gridSize, tiles = [], emptyPos = {}, imgSize = 300;

/* Start puzzle */
function startPuzzle(size) {
    gridSize = size;
    document.getElementById("puzzle-box").style.display = "inline-block";
    document.getElementById("puzzle-message").style.display = "none";

    const container = document.getElementById("puzzle-container");
    container.innerHTML = "";
    tiles = [];

    const imgSrc = puzzleImages[size - 2];
    const tileSize = imgSize / size;

    /* Create tiles */
    for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {

            if (r === size - 1 && c === size - 1) {
                emptyPos = { row: r, col: c };
                continue;
            }

            const tile = document.createElement("img");
            tile.src = imgSrc;
            tile.className = "tile";

            tile.dataset.row = r;
            tile.dataset.col = c;
            tile.dataset.rowOrig = r;
            tile.dataset.colOrig = c;

            tile.style.width = tileSize + "px";
            tile.style.height = tileSize + "px";
            tile.style.top = (r * tileSize) + "px";
            tile.style.left = (c * tileSize) + "px";

            tile.style.objectFit = "none";
            tile.style.objectPosition = `-${c * tileSize}px -${r * tileSize}px`;

            tile.addEventListener("click", () => moveTile(tile));

            container.appendChild(tile);
            tiles.push(tile);
        }
    }

    shuffleTiles();
}

/* Shuffle by making valid moves */
function shuffleTiles() {
    for (let i = 0; i < 200; i++) {
        const possible = tiles.filter(t => isNeighbor(t, emptyPos));
        const tile = possible[Math.floor(Math.random() * possible.length)];
        swapTile(tile);
    }
}

/* Check if tile touches empty space */
function isNeighbor(tile, pos) {
    const r = parseInt(tile.dataset.row);
    const c = parseInt(tile.dataset.col);
    return (r === pos.row && Math.abs(c - pos.col) === 1) ||
           (c === pos.col && Math.abs(r - pos.row) === 1);
}

/* Move tile */
function moveTile(tile) {
    if (isNeighbor(tile, emptyPos)) {
        swapTile(tile);
        checkSolved();
    }
}

/* Swap tile with empty space */
function swapTile(tile) {
    const tileSize = imgSize / gridSize;

    const oldRow = parseInt(tile.dataset.row);
    const oldCol = parseInt(tile.dataset.col);

    tile.dataset.row = emptyPos.row;
    tile.dataset.col = emptyPos.col;

    tile.style.top = (emptyPos.row * tileSize) + "px";
    tile.style.left = (emptyPos.col * tileSize) + "px";

    emptyPos.row = oldRow;
    emptyPos.col = oldCol;
}

/* Check solved */
function checkSolved() {
    const solved = tiles.every(tile =>
        tile.dataset.row == tile.dataset.rowOrig &&
        tile.dataset.col == tile.dataset.colOrig
    );

    if (solved) {
        const msgBox = document.getElementById("puzzle-message");
        msgBox.innerText = messages[gridSize - 2];
        msgBox.style.display = "block";
    }
}

/* Close puzzle */
function closePuzzle() {
    document.getElementById("puzzle-box").style.display = "none";
    document.getElementById("puzzle-container").innerHTML = "";
    document.getElementById("puzzle-message").style.display = "none";
}
</script>

</body>
</html>
