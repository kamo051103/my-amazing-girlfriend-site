<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Puzzle Surprise</title>
<style>
body { font-family: Arial, sans-serif; background: #ffe6ec; margin:0; padding:0; display:flex; flex-direction:column; align-items:center; }
#puzzle-container { position: relative; margin-top: 20px; }
.tile {
    position: absolute;
    box-sizing: border-box;
    border: 1px solid #fff;
    cursor: pointer;
    transition: top 0.3s, left 0.3s;
}
#controls { margin-top: 20px; }
button { padding: 10px 20px; margin: 5px; background:#ff4d6d; color:white; border:none; border-radius:6px; cursor:pointer; }
#message { margin-top:20px; display:none; background:white; padding:20px; border-radius:12px; max-width:400px; text-align:center; box-shadow:0 4px 12px rgba(0,0,0,0.2); }
#back-btn { display:none; margin-top:20px; }
</style>
</head>
<body>

<h2>Puzzle Surprise</h2>
<div id="controls">
    <button onclick="startPuzzle(2)">2x2</button>
    <button onclick="startPuzzle(3)">3x3</button>
    <button onclick="startPuzzle(4)">4x4</button>
</div>

<div id="puzzle-container"></div>
<div id="message"></div>
<button id="back-btn" onclick="closePuzzle()">Back</button>

<script>
const messages = [
    "You are the best girlfriend!",
    "You make me so happy and I love you so much!",
    "I am sorry"
];

const puzzleImages = [
    "Puzzel1.JPG", // 2x2
    "Puzzel2.JPG", // 3x3
    "Puzzel3.jpeg" // 4x4
];

let gridSize, tiles=[], emptyPos={}, container, imgWidth, imgHeight;

function startPuzzle(size) {
    gridSize = size;
    container = document.getElementById('puzzle-container');
    container.innerHTML = '';
    document.getElementById('message').style.display='none';
    document.getElementById('back-btn').style.display='inline-block';
    
    const imgSrc = puzzleImages[size-2]; // 2x2=>first, 3x3=>second, 4x4=>third
    const img = new Image();
    img.src = imgSrc;
    img.onload = function() {
        imgWidth = img.width;
        imgHeight = img.height;
        container.style.width = imgWidth+'px';
        container.style.height = imgHeight+'px';

        // Create tiles
        tiles=[];
        for(let r=0;r<size;r++){
            for(let c=0;c<size;c++){
                if(r===size-1 && c===size-1){
                    emptyPos={row:r,col:c};
                    continue; // leave last tile empty
                }
                const tile = document.createElement('img');
                tile.src = imgSrc;
                tile.className='tile';
                tile.dataset.row=r;
                tile.dataset.col=c;
                tile.dataset.rowOrig=r;
                tile.dataset.colOrig=c;
                tile.style.width=(imgWidth/size)+'px';
                tile.style.height=(imgHeight/size)+'px';
                tile.style.top=(r*(imgHeight/size))+'px';
                tile.style.left=(c*(imgWidth/size))+'px';
                tile.style.objectFit='none';
                tile.style.objectPosition=`-${c*(imgWidth/size)}px -${r*(imgHeight/size)}px`;
                tile.addEventListener('click', ()=>moveTile(tile));
                container.appendChild(tile);
                tiles.push(tile);
            }
        }
        shuffleTiles();
    }
}

function shuffleTiles(){
    // perform a number of random valid moves
    for(let i=0;i<1000;i++){
        const neighbors = tiles.filter(t=>isNeighbor(t,emptyPos));
        const tile = neighbors[Math.floor(Math.random()*neighbors.length)];
        swapWithEmpty(tile);
    }
}

function isNeighbor(tile,pos){
    const r=parseInt(tile.dataset.row);
    const c=parseInt(tile.dataset.col);
    return ( (r===pos.row && Math.abs(c-pos.col)===1) || (c===pos.col && Math.abs(r-pos.row)===1) );
}

function moveTile(tile){
    if(isNeighbor(tile,emptyPos)){
        swapWithEmpty(tile);
        checkSolved();
    }
}

function swapWithEmpty(tile){
    const tempTop = tile.style.top;
    const tempLeft = tile.style.left;
    tile.style.top = emptyPos.row*(imgHeight/gridSize)+'px';
    tile.style.left = emptyPos.col*(imgWidth/gridSize)+'px';

    const tileRow = parseInt(tile.dataset.row);
    const tileCol = parseInt(tile.dataset.col);

    tile.dataset.row = emptyPos.row;
    tile.dataset.col = emptyPos.col;

    emptyPos.row = tileRow;
    emptyPos.col = tileCol;
}

function checkSolved(){
    const solved = tiles.every(tile=>{
        return parseInt(tile.dataset.row)==tile.dataset.rowOrig && parseInt(tile.dataset.col)==tile.dataset.colOrig;
    });
    if(solved){
        document.getElementById('message').innerText = messages[gridSize-2];
        document.getElementById('message').style.display='block';
    }
}

function closePuzzle(){
    document.getElementById('puzzle-container').innerHTML='';
    document.getElementById('message').style.display='none';
    document.getElementById('back-btn').style.display='none';
}
</script>
</body>
</html>
